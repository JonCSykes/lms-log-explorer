import { RequestReceivedEvent, StreamPacketEvent } from './events';

/**
 * Pending requests waiting for packet correlation
 */
export interface PendingRequest {
  ts: string;
  requestEvent: RequestReceivedEvent;
}

/**
 * Correlate a packet with its request
 * Uses time-based heuristic since requests don't have chat IDs
 */
export function correlateRequestToPacket(
  pendingRequests: PendingRequest[],
  packetTs: string,
): { requestEvent?: RequestReceivedEvent; matchedIndex: number } {
  const packetTime = parseTimestampToMs(packetTs);
  
  // Find the closest request within window (default: 5 seconds)
  constwindowMs = 5000;
  
  let closestDiff = Infinity;
  let matchedIndex = -1;
  
  for (let i = 0; i < pendingRequests.length; i++) {
    const requestTime = parseTimestampToMs(pendingRequests[i].ts);
    const diff = Math.abs(packetTime - requestTime);
    
    if (diff <= windowMs && diff < closestDiff) {
      closestDiff = diff;
      matchedIndex = i;
    }
  }
  
  if (matchedIndex !== -1) {
    return {
      requestEvent: pendingRequests[matchedIndex].requestEvent,
      matchedIndex,
    };
  }
  
  return { matchedIndex: -1 };
}

/**
 * Parse timestamp to milliseconds since epoch
 */
export function parseTimestampToMs(ts: string): number {
  // LM Studio format: YYYY-MM-DD HH:MM:SS
  const [date, time] = ts.split(' ');
  if (!date || !time) {
    return Date.now();
  }
  
  const [year, month, day] = date.split('-').map(Number);
  const [hour, minute, second] = time.split(':').map(Number);
  
  return Date.UTC(year, month - 1, day, hour, minute, second);
}

/**
 * Session correlation result
 */
export interface CorrelationResult {
  sessionchatId: string;
  requestEvent?: RequestReceivedEvent;
  packet: StreamPacketEvent;
}

/**
 * Link packets to requests and assign chat IDs
 */
export class SessionLinker {
  private pendingRequests: PendingRequest[] = [];
  
  /**
   * Add a pending request for later correlation
   */
  addRequest(request: RequestReceivedEvent): void {
    this.pendingRequests.push({
      ts: request.ts,
      requestEvent: request,
    });
  }
  
  /**
   * Try to correlate a packet with a pending request
   */
  linkPacket(packet: StreamPacketEvent): CorrelationResult {
    const { requestEvent, matchedIndex } = correlateRequestToPacket(
      this.pendingRequests,
      packet.ts,
    );
    
    const result: CorrelationResult = {
      sessionchatId: String(packet.data?.packetId || 'unknown'),
      packet,
    };
    
    if (requestEvent && matchedIndex !== -1) {
      result.requestEvent = requestEvent;
      // Remove from pending since we matched
      this.pendingRequests.splice(matchedIndex, 1);
    }
    
    return result;
  }
}
